/**
 * Copyright(c) Beijing Kungeek Science & Technology Ltd.
 */
package com.kungeek.ftsp.api.infrastructure.service;

import com.kungeek.ftsp.api.infrastructure.context.FtspUserContextHolder;
import com.kungeek.ftsp.api.infrastructure.util.SendMail;
import com.kungeek.ftsp.api.util.FtspPageInfo;
import com.kungeek.ftsp.api.util.PageType;
import com.kungeek.ftsp.api.util.PagedResult;
import com.kungeek.ftsp.api.vo.FtspValueObject;
import org.apache.commons.collections.CollectionUtils;
import org.apache.ibatis.mapping.BoundSql;
import org.apache.ibatis.mapping.MappedStatement;
import org.apache.ibatis.session.Configuration;
import org.apache.ibatis.session.RowBounds;
import org.mybatis.spring.SqlSessionTemplate;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.BatchPreparedStatementSetter;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.object.BatchSqlUpdate;
import org.springframework.util.StringUtils;

import javax.annotation.Resource;
import javax.sql.DataSource;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.List;
import java.util.function.Function;
import java.util.stream.Collectors;

/**
 *
 * <pre>
 * 服务实现类必须继承的基类。
 * </pre>
 *
 * @version 1.00.00
 *
 *          <pre>
 * 修改记录
 *    修改后版本:     修改人：  修改日期:     修改内容:
 * </pre>
 */
public abstract class DefaultService {
	private final static int DEFAULT_BATCH_COUNT = 100;

	protected final Logger log = LoggerFactory.getLogger(this.getClass());


	@Autowired
	private IKeyGen keyGen;
	@Autowired
	private DataSource dataSource;
	@Autowired
	private SqlSessionTemplate sqlSessionTemplate;
	@Autowired
	private SendMail sendMail;

	@Resource(name="ftsp_infrastructure_jdbcTemplate")
	private JdbcTemplate ftspJdbcTemplate;



	/**JDBC批量执行SQL
	 * @param sql
	 * @param valueList
	 * @return
	 */
	public int batchJDBCSQL(String sql,List<Object[]> valueList) {

		int[] batchUpdate = ftspJdbcTemplate.batchUpdate(sql, new BatchPreparedStatementSetter() {

			@Override
			public int getBatchSize() {
				return valueList.size();
			}

			@Override
			public void setValues(PreparedStatement paramPreparedStatement, int paramInt) throws SQLException {
				Object[] objs = valueList.get(paramInt);
				for(int i=0;i<objs.length;i++) {
					paramPreparedStatement.setString(i+1, objs[i].toString());
				}

			}

		});
		int updateCount = 0;
		for (int i : batchUpdate) {
			updateCount += i;
		}
		return updateCount;

	}



	/**
	 * 借助BatchSqlUpdate批量执行JDBC操作。
	 *
	 * @param sql
	 *            执行SQL，比如“update emp set sal=? where empno = ?”
	 * @param parameterTypes
	 *            参数类型，比如“new int[]{Types.FLOAT, Types.INTEGER}”
	 * @param valueList
	 *            参数值集合，每项值的数量要保持同参数类型的长度一致
	 */
	protected void batchCommitJDBC(String sql, int[] parameterTypes,
								   List<Object[]> valueList) {
		BatchSqlUpdate batchSqlUpdate = new BatchSqlUpdate(this.dataSource, sql);
		batchSqlUpdate.setTypes(parameterTypes);
		for (Object[] valueArray : valueList) {
			batchSqlUpdate.update(valueArray);
		}
		batchSqlUpdate.flush();
	}

	/**
	 * 设置 sqlSessionTemplate。
	 *
	 * @param sqlSessionTemplate
	 *            设置 sqlSessionTemplate。
	 */
	public void setSqlSessionTemplate(SqlSessionTemplate sqlSessionTemplate) {
		this.sqlSessionTemplate = sqlSessionTemplate;
	}

	/**
	 * 返回 sqlSessionTemplate。
	 *
	 * @return 返回 sqlSessionTemplate。
	 */
	public org.mybatis.spring.SqlSessionTemplate getSqlSessionTemplate() {
		return sqlSessionTemplate;
	}


	/**
	 * 分页查找。
	 * @param mapper   	Class<?>
	 * @param <T>   	类型
	 * @param parameter  Object 查询参数
	 * @param pageIndex  int	 页码
	 * @param pageSize    int	  	每页大小
	 * @return PagedResult<T> 查找到的结果
	 */
	@Deprecated
	public <T> PagedResult<T> pagedQuery(Class<?> mapper, Object parameter,
										 int pageIndex, int pageSize) {
		String queryMethod = "pagedQuery" ;
		return this.pagedQuery(mapper, queryMethod, parameter, pageIndex, pageSize) ;
	}

	/**
	 * 分页查找。
	 * @param mapper   	Class<?>
	 * @param <T>   	类型
	 * @param parameter  Object 查询参数
	 * @param ftspPageInfo  FtspPageInfo
	 * @return PagedResult<T> 查找到的结果
	 */
	public <T> PagedResult<T> pagedQuery(Class<?> mapper, Object parameter, FtspPageInfo ftspPageInfo) {
		String queryMethod = "pagedQuery" ;
		return this.pagedQuery(mapper, queryMethod, parameter, ftspPageInfo) ;
	}

	/**
	 * 分页查找。
	 * @param mapper   	Class<?>
	 * @param <T>   	类型
	 * @param parameter  Object 查询参数
	 * @param ftspPageInfo  FtspPageInfo
	 * @return PagedResult<T> 查找到的结果
	 */
	public <T> PagedResult<T> pagedQuery(Class<?> mapper, String queryMethod, Object parameter, FtspPageInfo ftspPageInfo) {
		return this.query(mapper, queryMethod, parameter, ftspPageInfo) ;
	}


	/**
	 * 分页查找。
	 * @param mapper		对应Mapper接口的class
	 * @param <T>   		类型
	 * @param queryMethod   分页查询方法
	 * @param parameter  	Object 查询参数
	 * @param pageIndex  	int	 页码
	 * @param pageSize    	int	  	每页大小
	 * @return PagedResult<T>  页面数据
	 */
	@Deprecated
	public <T> PagedResult<T> pagedQuery(Class<?> mapper, String queryMethod, Object parameter,
										 int pageIndex, int pageSize) {
		FtspPageInfo ftspPageInfo = new FtspPageInfo();
		ftspPageInfo.setPageType(PageType.PAGE);
		ftspPageInfo.setPageIndex(pageIndex);
		ftspPageInfo.setPageSize(pageSize);
		return query(mapper, queryMethod, parameter, ftspPageInfo);
	}

	/**
	 * 分页查找。
	 * @param mapper		对应Mapper的class
	 * @param <T>   		类型
	 * @param queryMethod   分页查询方法
	 * @param parameter  	Object 查询参数
	 * @param ftspPageInfo  FtspPageInfo
	 * @return PagedResult<T>  页面数据
	 *
	 */
	@SuppressWarnings("unchecked")
	public <T> PagedResult<T> query(Class<?> mapper, String queryMethod, Object parameter, FtspPageInfo ftspPageInfo) {
		RowBounds rb = this.getRowBounds(ftspPageInfo);
		String statement = this.getStatement(mapper, queryMethod);
		Configuration config = this.getSqlSessionTemplate().getConfiguration();
		if (!config.hasStatement(statement)) {
			throw new IllegalArgumentException(String.format("请提供【%s】用于分页查询的方法！", statement));
		}

		String statementCount = statement + "_count";
		if (!config.hasStatement(statementCount)) {
			throw new IllegalArgumentException(String.format("请提供【%s】用于分页查询统计的方法！", statementCount));
		}

		List<T> list = (List<T>) this.getSqlSessionTemplate().selectList(statement, parameter, rb);
		// V2.4 API去除session缓存 （bug：APP分页查询,由于获取的缓存total与实际数据条数不一致造成页面显示有误）
		Long total = this.getSqlSessionTemplate().selectOne(statementCount, parameter);

		if(total == null){
			total=0l;
		}


		// 使用缓存机制读取Total。
//		Long total = this.queryTotalByUseCache(statementCount, pageIndex,	parameter) ;
		PagedResult<T> pr = new PagedResult<T>(list, total, ftspPageInfo);
//		pr.setSql(this.revolveRuntimeSQL(statement, parameter));
		return pr;
	}

	/**
	 * 返回查询的List结果集合。
	 * @param mapper Class
	 * @param <T>   	类型
	 * @param statementSelect   String
	 * @param parameter 参数
	 * @return List List<T> 返回的list结果
	 */
	@SuppressWarnings("unchecked")
	public<T>  List<T> selectList(Class<?> mapper ,String statementSelect,Object parameter){
		String statement = this.getStatement(mapper, statementSelect);
		return (List<T>) this.getSqlSessionTemplate().selectList(statement, parameter);
	}

	/**
	 * 查询行数据记录数。
	 * @param mapper Class
	 * @param <T>   	类型
	 * @param statementCount String
	 * @param parameter Object
	 * @return long 返回查询到的记录数
	 */
	public<T>  long countRows(Class<?> mapper ,String statementCount,Object parameter){
		String statement = this.getStatement(mapper, statementCount);
		Long total = (Long) this.getSqlSessionTemplate().selectOne(
				statement, parameter);
		if(total == null){
			return 0;
		}
		return total.longValue();
	}

	/**
	 * 使用缓存机制读取Total。
	 *
	 * @param statementCount String
	 * @param pageIndex    int
	 * @param parameter Object
	 * @return Long
	 *
	 * @author zengziwen@foresee.cn 2012-12-15
	 */
	public Long queryTotalByUseCache(String statementCount, int pageIndex,
									 Object parameter) {
		Long total = 0L;
		/*
		// 1、缓存total数 但pageIndex=1时，不进行缓存。 2、 对SQL进行哈希。
		String userRunSql = this.createCacheCountSQLKey(statementCount,
				parameter);
		Long cacheTotal = null;
		String cacheKey = null;
		try {
			if (userRunSql != null && this.existsHttpSession()) {
				cacheKey = String.valueOf(userRunSql.hashCode());
				cacheTotal = (Long) ContextUtil.get("SQL_COUNT_KEY" + cacheKey,
						ContextUtil.SCOPE_SESSION);
			}
		} catch (Exception e) {
			log.error("读取cacheTotal缓存失败!", e);
		}
		if (cacheTotal != null && pageIndex > 1) {
			total = cacheTotal;
			if(log.isDebugEnabled()){
				log.debug(statementCount + "获取缓存total:" + total);
			}
		} else {
			total = (Long) this.getSqlSessionTemplate().selectOne(
					statementCount, parameter);
			if (cacheKey != null && this.existsHttpSession()) {
				ContextUtil.put("SQL_COUNT_KEY" + cacheKey, total,
						ContextUtil.SCOPE_SESSION);
			}
		}
		*/
		total = (Long) this.getSqlSessionTemplate().selectOne(statementCount, parameter);
		return total == null ? Long.valueOf(0) : total ;
	}

	/**
	 * 获取运行时sql。
	 *
	 * @param statementId String
	 * @param parameter Object
	 * @return String
	 */
	public String revolveRuntimeSQL(String statementId, Object parameter) {
		try {
			Configuration configuration = this.getSqlSessionTemplate().getConfiguration();
			MappedStatement mappedStatement = configuration.getMappedStatement(statementId);
			BoundSql boundSql = mappedStatement.getBoundSql(parameter);
			return boundSql.getSql();
		} catch (Exception e) {
			log.error("", e);
		}
		return "(读到SQL过程中发生错误.)";
	}

	/**
	 * 构建运count SQL与参数组成Key。
	 *
	 * @param statementId
	 *            String
	 * @param parameter
	 *            Object
	 * @return String
	 */
/*
	private String createCacheCountSQLKey(String statementId, Object parameter) {
		try {
			Configuration configuration = this.getSqlSessionTemplate()
					.getConfiguration();
			MappedStatement mappedStatement = configuration
					.getMappedStatement(statementId);
			BoundSql boundSql = mappedStatement.getBoundSql(parameter);
			List<ParameterMapping> list = boundSql.getParameterMappings();
			StringBuffer sbf = new StringBuffer();
			if (list != null) {
				for (ParameterMapping p : list) {
					String name = p.getProperty();
					Object object = boundSql.getAdditionalParameter(name);
					String value = object == null ? "" : object.toString();// TODO
																			// 可能存嵌套其它对象的情况，暂不考虑。
																			// add
																			// by
																			// zengzw
					sbf.append(name).append("=").append(value).append(";");
				}
			}
			return boundSql.getSql() + ";" + sbf.toString();
		} catch (Exception e) {
			log.error("", e);
		}
		return null;
	}
*/
	/**
	 * 获取Statement。
	 * @param key String
	 * @return String
	 */
	protected String getStatement(String key) {
		String statement = null;
		if (key != null && key.indexOf(".") > -1) {
			statement = key;
		} else {
			statement = this.getClass().getName() + "." + key;
		}
		return statement;
	}

	/**
	 * 获取Object中的Statement。
	 * @param obj Class<?>
	 * @param key String
	 * @return String
	 */
	protected String getStatement(Class<?> obj, String key) {
		String statement = null;
		if (key != null && key.indexOf(".") > -1) {
			statement = key;
		} else {
			statement = obj.getName() + "." + key;
		}
		return statement;
	}

	/**
	 * 2015年12月30日获取行边界。
	 * @param ftspPageInfo FtspPageInfo
	 * @return RowBounds 获取到的行边界
	 */
	protected RowBounds getRowBounds(FtspPageInfo ftspPageInfo) {

		int offset = 0;
		if (ftspPageInfo.getPageType() == PageType.PAGE) {
			if (ftspPageInfo.getPageIndex() <= 0) {
				ftspPageInfo.setPageIndex(1);
			}
			offset = (ftspPageInfo.getPageIndex() - 1) * ftspPageInfo.getPageSize();
		} else {
			offset = ftspPageInfo.getIndex() - 1;
		}
		RowBounds rb = new RowBounds(offset, ftspPageInfo.getPageSize());
		return rb;
	}

	/**
	 * 获取UUID的接口。
	 * @return IKeyGen 得到的uuid接口
	 */
	public IKeyGen getKeyGen() {
		return keyGen;
	}

	public String getUUIDKey(){
		return getKeyGen().getUUIDKey();
	}

	/**
	 * 获取发送的信息。
	 * @return SendMail 发送的信息
	 */
	public SendMail getSendMail() {
		return sendMail;
	}

	/**
	 * 获取当前用户id。
	 *
	 * @return String
	 */
	public String getCurUserId() {
		return FtspUserContextHolder.getUserId();
	}

	/**
	 * 渠道信息。
	 *
	 * @return String
	 */
	public String getChannel() {
		return FtspUserContextHolder.getChannel();
	}

	/**
	 * 获取微税号。
	 *
	 * @return 微税号
	 */
	public String getMtNo() {
		return FtspUserContextHolder.getMtNo();
	}

	/**
	 * 填充表实体的ID信息。
	 * @param obj
	 */
	protected void fillIdInfo(FtspValueObject obj){
		if(StringUtils.isEmpty(obj.getId())){
			obj.setId(this.getKeyGen().getUUIDKey());
		}
	}

	/**
	 * 填充表实体的ID信息。
	 * @param list
	 */
	protected void fillIdInfo(Collection<? extends FtspValueObject> list){
		if(CollectionUtils.isNotEmpty(list)){
			for (FtspValueObject obj: list){
				this.fillIdInfo(obj);
			}
		}

	}
	/**
	 * 填充表实体所有的基础信息。
	 * 包括id, createDate,updateDate,createUser,updateUser
	 * @param obj
	 */
	protected void fillAllInfo(FtspValueObject obj){
		this.fillIdInfo(obj);
		this.fillBaseInfo(obj);
	}

	/**
	 * 填充表实体所有的基础信息。
	 * 包括id, createDate,updateDate,createUser,updateUser
	 * @param list
	 */
	protected void fillAllInfo(Collection<? extends FtspValueObject> list){
		for (FtspValueObject obj: list){
			this.fillIdInfo(obj);
			this.fillBaseInfo(obj);
		}
	}

	/**
	 * 填充表实体的基础信息。
	 * 包括createDate,updateDate,createUser,updateUser
	 * @param obj
	 */
	protected void fillBaseInfo(FtspValueObject obj){
		this.fillBaseCreateInfo(obj);
		this.fillBaseUpdateInfo(obj);
	}

	/**
	 * 填充表实体的基础信息。
	 * 包括createDate,updateDate,createUser,updateUser
	 * @param list
	 */
	protected void fillBaseInfo(Collection<? extends FtspValueObject> list){
		if(CollectionUtils.isNotEmpty(list)){
			for (FtspValueObject obj: list){
				this.fillBaseCreateInfo(obj);
				this.fillBaseUpdateInfo(obj);
			}
		}

	}

	/**
	 * 填充表实体的基础创建信息。
	 * 包括createDate,createUser
	 * @param obj
	 */
	protected void fillBaseCreateInfo(FtspValueObject obj){
		if(null == obj.getCreateDate()){
			obj.setCreateDate(new Date());
		}

		if(StringUtils.isEmpty(obj.getCreateUser())){
			obj.setCreateUser(getCurUserId());
		}
	}

	/**
	 * 填充表实体的基础创建信息。
	 * 包括createDate,createUser
	 * @param valueObjectList
	 */
	protected void fillBaseCreateInfo(List<? extends FtspValueObject> valueObjectList){
		for(FtspValueObject valueObject: valueObjectList){
			fillBaseCreateInfo(valueObject);
		}
	}

	/**
	 * 填充表实体的基础更新信息。
	 * 包括createDate,updateDate,createUser,updateUser
	 * @param obj
	 */
	protected void fillBaseUpdateInfo(FtspValueObject obj){
		if(null == obj.getUpdateDate()){
			obj.setUpdateDate(new Date());
		}

		if(StringUtils.isEmpty(obj.getUpdateUser())){
			obj.setUpdateUser(getCurUserId());
		}
	}

	/**
	 * 批量插入数据，分次插入，每次插入BATCH_COUNT条
	 * @param collection
	 * @param insertFunc
	 * @param <T>
	 * @return
	 */
	protected <T> Integer batchInsert(List<T> collection, Function<List<T>, Integer> insertFunc){
		return this.batchInsert(collection, insertFunc, DEFAULT_BATCH_COUNT);
	}

	/**
	 * 批量插入数据，并按照batchCount分批次插入
	 * @param collection
	 * @param insertFunc
	 * @param batchCount
	 * @param <T>
	 * @return
	 */
	protected <T> Integer batchInsert(List<T> collection, Function<List<T>, Integer> insertFunc, int batchCount){

		Integer count = 0;
		if(CollectionUtils.isNotEmpty(collection)){
			if(collection.get(0) instanceof FtspValueObject){
				List<FtspValueObject> fillList = collection.stream().map( ele -> (FtspValueObject)ele).collect(Collectors.toList());
				this.fillIdInfo(fillList);
				this.fillBaseCreateInfo(fillList);
			}

			collection = new ArrayList<>(collection);
			List<T> tmpList;
			do{
				tmpList = collection.subList(0, batchCount > collection.size()? collection.size(): batchCount);
				count += insertFunc.apply(tmpList);
				tmpList.clear();
			}while (CollectionUtils.isNotEmpty(collection));
		}

		return count;
	}
}
